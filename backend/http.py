# -*- coding: utf-8 -*-
'''
Created on Sep 22, 2014

@author:  Edis Sehalic (edis.sehalic@gmail.com)
'''
import json
import datetime
import webapp2

from backend import orm, util, io, mem, settings

CSRF_KEY = '_csrf'
COOKIE_USER_KEY = 'auth'
 
 
class InvalidRouteError(Exception):
  pass


def json_output(s, **kwargs):
  '''Converts all known and complex values generated by the application to json format.'''
  defaults = {'indent': 2, 'check_circular': False, 'cls': JSONEncoder}
  defaults.update(kwargs)
  return json.dumps(s, **defaults)


class JSONEncoder(json.JSONEncoder):
    '''An encoder that produces JSON safe to embed in HTML.

    To embed JSON content in, say, a script tag on a web page, the
    characters &, < and > should be escaped. They cannot be escaped
    with the usual entities (e.g. &amp;) because they are not expanded
    within <script> tags.
    
    Also its `default` function will properly format data that is usually not serialized by json standard.
    '''
    
    def default(self, o):
      if isinstance(o, datetime.datetime):
         return o.strftime(settings.DATETIME_FORMAT)
      if isinstance(o, orm.Key):
         return o.urlsafe()
      if hasattr(o, 'get_output'):
        try:
          return o.get_output()
        except TypeError as e:
          pass
      if hasattr(o, 'get_meta'):
        try:
         return o.get_meta()
        except TypeError:
         pass
      try:
        out = str(o)
        return out
      except TypeError:
        pass
      return json.JSONEncoder.default(self, o)
  
    def iterencode(self, o, _one_shot=False):
      chunks = super(JSONEncoder, self).iterencode(o, _one_shot)
      for chunk in chunks:
        chunk = chunk.replace('&', '\\u0026')
        chunk = chunk.replace('<', '\\u003c')
        chunk = chunk.replace('>', '\\u003e')
        yield chunk
        
   
class BaseRequestHandler(webapp2.RequestHandler):
  
  '''General-purpose handler from which all other handlers must derrive from.'''
  
  autoload_current_account = True
  autovalidate_csrf = False # generally all requests for authenticated users should be carrying _csrf
  
  def __init__(self, *args, **kwargs):
    super(BaseRequestHandler, self).__init__(*args, **kwargs)
    self.current_account = None
    self.current_csrf = None
  
  def get_input(self):
    special = '__body__'
    try:
      dicts = json.loads(self.request.body)
    except:
      special_data = self.request.get(special)
      if special_data:
        dicts = json.loads(special_data)
      else:
        dicts = {}
    newparams = {}
    for param_key in self.request.params.keys():
      if param_key == special:
        continue
      value = self.request.params.getall(param_key)
      if len(value) == 1:
         value = value[0]
      if param_key in dicts:
        dictval = dicts.get(param_key)
        if isinstance(dictval, list):
          if isinstance(value, list):
            dictval.extend(value)
          else:
            dictval.append(value)
          continue
      newparams[param_key] = value
    dicts.update(newparams)
    return dicts
  
  def json_output(self, s, **kwargs):
    ''' Wrapper for json output for self usage to avoid imports from backend http '''
    return json_output(s, **kwargs)
   
  def send_json(self, data):
    ''' sends `data` to be serialized in json format, and sets content type application/json utf8'''
    ent = 'application/json;charset=utf-8'
    if self.response.headers.get('Content-Type') != ent:
       self.response.headers['Content-Type'] = ent
    self.response.write(self.json_output(data))
   
  def before(self):
    """
    This function is fired just before the handler logic is executed
    """
    pass
   
  def after(self):
    """
    This function is fired just after the handler is executed
    """
    pass
 
  def get(self, *args, **kwargs):
    return self.respond(*args, **kwargs)
       
  def post(self, *args, **kwargs):
    return self.respond(*args, **kwargs)
       
  def respond(self, *args, **kwargs):
    self.abort(404)
    self.response.write('<h1>404 Not found</h1>')
    
  def load_current_account(self):
    ''' Loads current user from the local thread and sets it as self.current_account for easier handler access to it.
      Along with that, also sets if the request came from taskqueue or cron, based on app engine headers.'''
    if self.current_account is None and self.autoload_current_account:
      from backend.models.account import Account
      Account.set_current_account_from_auth_code(self.request.cookies.get(COOKIE_USER_KEY))
      current_account = Account.current_account()
      current_account.set_taskqueue(self.request.headers.get('X-AppEngine-QueueName', None) != None) # https://developers.google.com/appengine/docs/python/taskqueue/overview-push#Python_Task_request_headers
      current_account.set_cron(self.request.headers.get('X-Appengine-Cron', None) != None) # https://developers.google.com/appengine/docs/python/config/cron#Python_app_yaml_Securing_URLs_for_cron
      self.current_account = current_account
      
  def load_csrf(self):
    if self.current_csrf is None and self.autoload_current_account:
      input = self.get_input()
      csrf_cookie_value = input.get(CSRF_KEY)
      self.current_csrf = csrf_cookie_value
  
  def validate_csrf(self):
    if self.autoload_current_account and self.autovalidate_csrf:
      if not self.current_account._is_guest and (self.current_account._csrf != self.current_csrf):
        self.abort(403)
  
  @orm.toplevel
  def dispatch(self):
    
    self.load_current_account()
    self.load_csrf()
    self.validate_csrf()

    try:
      self.before()
      super(BaseRequestHandler, self).dispatch()
      self.after()
    finally:
      # support our memcache wrapper lib temporary variables, and release them upon request complete
      mem._local.__release_local__()
      
      
class Endpoint(BaseRequestHandler):
 
  def respond(self):
    output = io.Engine.run(self.get_input())
    self.send_json(output)
    

class IOEngineRun(BaseRequestHandler):
     
  def respond(self):
    util.log('Begin IOEngineRun execute')
    input = self.get_input()
    io.Engine.run(input)
    util.log('End IOEngineRun execute')
    

class Install(BaseRequestHandler):
  
  def respond(self):
    out = []
    only = self.request.get('only', '').split(',')
    for model, action in [('12', 'update'), ('24', 'update'), ('17', 'update_unit'), ('17', 'update_currency')]:
      if only and model not in only:
        continue
      out.append(io.Engine.run({'action_model' : model, 'action_id' : action}))
    self.send_json(out)
    

# We expose only paths that the "backend" module will serve. Note the prefix /backend/*
# @todo WSGI application instance should not be here though, it should follow similar pattern like in frontend.
# although, this is far too simple (we do not expect many http handlers in the future) for fragmentation
app = webapp2.WSGIApplication((('/backend/endpoint', Endpoint),
                               ('/backend/task/io_engine_run', IOEngineRun),
                               ('/backend/install', Install)), debug=settings.DEBUG)